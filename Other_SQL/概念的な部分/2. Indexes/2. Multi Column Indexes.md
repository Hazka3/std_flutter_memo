
- Multi-Column-Indexes (複合インデックス) は、一つのテーブル内の複数のカラムを組み合えわせて作られたインデックスのことを指す
- 単一インデックスとは違い、複合インデックスはクエリ条件に複数ののカラムが使用されるとき、性能をより最適化できる


# <font color="#00b050">注意や補足等</font>


※ 作成したクエリに対し、事前に実行計画を確認してみておくことをおすすめ
```sql
-- 例
EXPLAIN query plan SELECT A FROM table_name WHERE B > 10
```
![[multi_column_indexes_1.png]]

1. 先頭カラムの有線処理
   
   複合インデックスは先頭カラムから順に順序付きで構築される。
   ```sql
	CREATE INDEX idx_name on table_name (A, B, C)
	```
	上記のような複合インデックスを作成すると、Aの順序に基づいてデータを並び替えた上で、同じA値ごとにBの順序が保持される形でインデックスが作成される。
	
	インデックススキャンの一部利用や部分的なフルスキャンが発生することもある。
	クエリの検索条件にAの値が固定されていれば、Aを固定してB, C... のカラムの値もインデックスで連続的に検索できるが、Aが固定されていない状態 (<, >, BETWEEN などの範囲検索) は、次に続くBカラム以降の順序が特定できないため、インデックスの連続性が失われる。この場合は、Aの範囲検索ではAカラムのみのインデックスが使用され、Aに一致する範囲内のB、Cカラムはフルテーブルスキャンで探索される。
	
		インデックスが正しく適用される例
	```sql
		SELECT * FROM table_name WHERE A = 2000 AND B > 10
			
		-- 条件の順番は関係ない
		SELECT * FROM table_name WHERE C > 10 AND A = 10
		
```

		インデックスが正しく適用されない例 
	```sql
		-- 先頭カラムが不明, Full Scan
		SELECT * FROM table_name WHERE B = 2000 AND C > 10
		
		-- 先頭カラムが範囲検索となり、
		-- 条件Aに対してのみインデックス検索が行われる
		SELECT * FROM table_name WHERE A > 2000 AND C < 10
```
		※ いずれも先頭カラムが固定されていない状態

2. クエリの最適化
   
   複合クエリは、複数のカラムが組み合わさった条件で頻繁に検索が行われる場合に使用することで、効率を最大限にすることができる。
   例えば  A = 1, B=1 のような条件で検索される場合が多ければ、 A, Bでインデックスを生成するとよい。