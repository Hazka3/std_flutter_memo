
AnimationController の value が変わるだけでは 画面の build method が再実行されないため、AnimationController を forword / stop / reverse などをしただけだと、画面上ではアニメーションが再生されていないようにみえる。

例えば Animationcontroller を以下のように..addListener を追加し、値が変わるたびにsetStateを実行させる方法があるにはあるが、setStateはアニメーションwidgetのみではなく、build method全体をレンダリングし直すため、画面上に要素が多い場合は使ってはいけない (要素が少ない場合でも、アニメーションとは関係ない widgets を再度レンダリングするので、あまり適切な方法とは言えない)

#### 悪いコード例
```dart
  late final AnimationController _animationController = AnimationController(
    vsync: this,
    duration: const Duration(seconds: 10),
  )..addListener(() {
      setState(() {});
    });
```

AnimationController の value が変更されたとき、UI と通信することに特化したwidgetが存在する。それがAnimatedBuilderである

# <font color="#c0504d">AnimatedBuilderとは</font>

- AnimationController の値の変化を listen したい widget に wrap して使う

-  [animation] にAnimationController を渡し、AnimationController の値が変わる`(アニメーションが進行する)`たびに、[builder] 関数が実行される

- AnimationController の value は基本的に 0.0 ~ 1.0 のような double 型の値を取るが 、カラーアニメーションなどには使えないため、widget に controller の value をそのまま渡すような使い方はあまりしない。そのような場合は、Tween や Animation を使って値を変換して使う。シンプルな value を使うことが目的なら、[[1. Implicitly Animated Widgets]] を使う方が楽である。

#### コード例

```dart
AnimatedBuilder(
              animation: _animationController,
              builder: (context, child) {
                return Text(
                  "${_animationController.value}",
                  style: const TextStyle(fontSize: 50),
                );
              },
            ),
```

